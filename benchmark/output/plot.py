# GENERATED BY chatGPT (o1) on Jan 17, 2025
import os
import json
import pandas as pd
import plotly.graph_objects as go
from plotly.offline import plot

def load_data_from_output_folders(base_dir='.'):
    """
    Recursively search for folders named 'output-<node_id>'
    within base_dir. For each node folder, read the JSON file 
    named 'node-<node_id>.json' and extract the metrics.
    
    Returns a DataFrame with columns:
       [
         'node_id', 'timestamp', 'disabled_routes_count', ...,
         'redundancy', ...
       ]
    """
    df_list = []
    
    # Scan all items in the base directory
    for item in os.listdir(base_dir):
        folder_path = os.path.join(base_dir, item)
        
        # We only want directories named "output-<node_id>"
        if (
            os.path.isdir(folder_path) and 
            item.startswith("output-")
        ):
            # Extract node_id from folder name
            # e.g. "output-2" -> node_id = "2"
            _, node_id_str = item.split("-", maxsplit=1)
            
            # Construct the JSON filename
            json_file = os.path.join(folder_path, f"node-{node_id_str}.json")
            
            # Check if the JSON file exists
            if os.path.isfile(json_file):
                with open(json_file, 'r') as f:
                    data = json.load(f)
                
                # Each JSON has a "metrics" key containing a list
                for entry in data.get("metrics", []):
                    # Attach the node_id to each record
                    entry["node_id"] = node_id_str
                    
                    # Keep timestamps as-is for now (assume ms).
                    # We'll convert later to relative seconds.
                    df_list.append(entry)
    
    # Convert to DataFrame
    if not df_list:
        return pd.DataFrame()
    
    df = pd.DataFrame(df_list)
    return df

def create_interactive_figure(df, default_metric="redundancy"):
    """
    Create a Plotly figure that shows one line per (node_id, metric),
    with a dropdown menu to switch which metric is displayed.
    
    By default, only the traces for `default_metric` are visible, 
    and all nodes appear in the legend so the user can hide/show them.
    """
    if df.empty:
        raise ValueError("No data found. Make sure the JSON files exist and contain 'metrics'.")

    # Identify all metrics in the DataFrame (besides timestamp and node_id)
    ignore_cols = {"timestamp", "node_id", "relative_timestamp"}
    all_cols = set(df.columns)
    metric_cols = list(all_cols - ignore_cols)
    
    if not metric_cols:
        raise ValueError("No metric columns found in the data.")
    
    # If default_metric not in the list, just pick the first one
    if default_metric not in metric_cols:
        default_metric = metric_cols[0]
    
    # Sort metrics (optional, for nicer dropdown ordering)
    metric_cols.sort()
    
    # Convert 'timestamp' to a relative timestamp (in seconds):
    # 1. Find the earliest timestamp
    t0 = df["timestamp"].min()
    # 2. Create a new column "relative_timestamp" in seconds
    #    (assuming original 'timestamp' is in ms)
    df["relative_timestamp"] = (df["timestamp"] - t0) / 1000.0

    # Grab the unique list of nodes
    node_ids = df["node_id"].unique()
    
    # We'll create one trace for each (metric, node_id) pair,
    # but only the traces for the currently active metric are visible.
    # Then we use update menus to show/hide the relevant traces.
    fig = go.Figure()
    
    # Keep track of the trace indices in the same order as we add them
    # For each metric, we will store the list of trace indices that belong to it.
    metric_to_trace_indices = {m: [] for m in metric_cols}
    
    # Add a trace for each (metric, node_id) pair
    for metric in metric_cols:
        for node in node_ids:
            node_mask = (df["node_id"] == node)
            # Sort by relative_timestamp to ensure line is drawn in ascending time
            node_df = df[node_mask].sort_values(by="relative_timestamp")
            
            # Create a line trace
            trace = go.Scatter(
                x=node_df["relative_timestamp"],
                y=node_df[metric],
                mode='lines+markers',
                name=f"Node {node}",
                # By default, set visibility to True only if this metric is the default.
                visible=(metric == default_metric)
            )
            
            fig.add_trace(trace)
            metric_to_trace_indices[metric].append(len(fig.data) - 1)
    
    # Build the 'updatemenus' to switch which metric is visible
    def make_visibility_array(selected_metric):
        total_traces = len(fig.data)
        visibility = [False] * total_traces
        for idx in metric_to_trace_indices[selected_metric]:
            visibility[idx] = True
        return visibility

    buttons = []
    for m in metric_cols:
        buttons.append(
            dict(
                label=m,
                method='update',
                args=[
                    {"visible": make_visibility_array(m)},
                    {"title": f"Metric: {m}"}
                ]
            )
        )
    
    updatemenus = [
        dict(
            active=metric_cols.index(default_metric),
            x=0.0,
            xanchor="left",
            y=1.15,
            yanchor="top",
            buttons=buttons
        )
    ]
    
    # Crop the x-axis to show from 0 to the maximum relative timestamp
    max_rel_ts = df["relative_timestamp"].max()
    
    fig.update_layout(
        title=f"Metric: {default_metric}",
        xaxis=dict(
            title="Seconds since first event",
            range=[0, max_rel_ts]  # Crop from the earliest to the latest
        ),
        yaxis=dict(
            title="Value (unitless)"
        ),
        updatemenus=updatemenus,
        legend=dict(
            orientation="v",
            x=1.02, 
            xanchor="left", 
            y=1.0, 
            yanchor="top"
        ),
        margin=dict(l=50, r=200, t=100, b=50)
    )

    return fig

def main():
    # 1. Load the DataFrame from all the JSON files in ./output-<node id>/node-<node id>.json
    df = load_data_from_output_folders(base_dir='.')
    
    # 2. Create the interactive figure
    #    Default to showing 'redundancy' if it exists, else pick the first metric found
    fig = create_interactive_figure(df, default_metric="redundancy")
    
    # 3. Display the figure in your default browser. 
    #    This will generate an HTML file (plot.html) and open it.
    plot(fig, filename='plot.html', auto_open=True)

if __name__ == "__main__":
    main()
